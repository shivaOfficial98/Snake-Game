(()=>{"use strict";var e={709:(e,t,n)=>{var r=Object.freeze({__proto__:null,invariant:function(e,t){if(!e)throw new Error(`Invariant Violation: ${t}`)},isTrue:function(e,t){if(!e)throw new Error(`Assert Violation: ${t}`)},isFalse:function(e,t){if(e)throw new Error(`Assert Violation: ${t}`)},fail:function(e){throw new Error(e)}});const{assign:o,create:i,defineProperties:a,defineProperty:s,freeze:l,getOwnPropertyDescriptor:c,getOwnPropertyNames:d,getPrototypeOf:u,hasOwnProperty:h,isFrozen:f,keys:p,seal:m,setPrototypeOf:g}=Object,{isArray:y}=Array,{filter:v,find:w,indexOf:b,join:k,map:$,push:M,reduce:C,reverse:T,slice:E,splice:x,unshift:S,forEach:L}=Array.prototype,{fromCharCode:O}=String,{charCodeAt:H,replace:A,slice:I,toLowerCase:N}=String.prototype;function D(e){return void 0===e}function P(e){return null===e}function F(e){return!0===e}function _(e){return!1===e}function R(e){return"function"==typeof e}function j(e){return"object"==typeof e}function B(e){return"string"==typeof e}function W(){}const V={}.toString;function G(e){return e&&e.toString?y(e)?k.call($.call(e,G),","):e.toString():"object"==typeof e?V.call(e):e+""}function U(e,t){do{const n=c(e,t);if(!D(n))return n;e=u(e)}while(null!==e)}const K=["ariaActiveDescendant","ariaAtomic","ariaAutoComplete","ariaBusy","ariaChecked","ariaColCount","ariaColIndex","ariaColSpan","ariaControls","ariaCurrent","ariaDescribedBy","ariaDetails","ariaDisabled","ariaErrorMessage","ariaExpanded","ariaFlowTo","ariaHasPopup","ariaHidden","ariaInvalid","ariaKeyShortcuts","ariaLabel","ariaLabelledBy","ariaLevel","ariaLive","ariaModal","ariaMultiLine","ariaMultiSelectable","ariaOrientation","ariaOwns","ariaPlaceholder","ariaPosInSet","ariaPressed","ariaReadOnly","ariaRelevant","ariaRequired","ariaRoleDescription","ariaRowCount","ariaRowIndex","ariaRowSpan","ariaSelected","ariaSetSize","ariaSort","ariaValueMax","ariaValueMin","ariaValueNow","ariaValueText","role"],{AriaAttrNameToPropNameMap:z,AriaPropNameToAttrNameMap:q}=(()=>{const e=i(null),t=i(null);return L.call(K,(n=>{const r=N.call(A.call(n,/^aria/,(()=>"aria-")));e[r]=n,t[n]=r})),{AriaAttrNameToPropNameMap:e,AriaPropNameToAttrNameMap:t}})(),Z=function(){if("object"==typeof globalThis)return globalThis;let e;try{Object.defineProperty(Object.prototype,"__magic__",{get:function(){return this},configurable:!0}),e=__magic__,delete Object.prototype.__magic__}catch(e){}finally{void 0===e&&(e=window)}return e}(),X=new Map([["accessKey","accesskey"],["readOnly","readonly"],["tabIndex","tabindex"],["bgColor","bgcolor"],["colSpan","colspan"],["rowSpan","rowspan"],["contentEditable","contenteditable"],["crossOrigin","crossorigin"],["dateTime","datetime"],["formAction","formaction"],["isMap","ismap"],["maxLength","maxlength"],["minLength","minlength"],["noValidate","novalidate"],["useMap","usemap"],["htmlFor","for"]]),Y=new Map;function Q(e){const t=q[e];if(!D(t))return t;const n=X.get(e);if(!D(n))return n;const r=Y.get(e);if(!D(r))return r;let o="";for(let t=0,n=e.length;t<n;t++){const n=H.call(e,t);o+=n>=65&&n<=90?"-"+O(n+32):O(n)}return Y.set(e,o),o}function J(e){return void 0===Object.getOwnPropertyDescriptor(Element.prototype,e)}const ee=new WeakMap;function te(e){let t=ee.get(e);return void 0===t&&(t={},ee.set(e,t)),t}function ne(e){const t=function(e,t){return{get(){const n=te(this);return h.call(n,e)?n[e]:this.hasAttribute(t)?this.getAttribute(t):null},set(n){const r=null==(o=n)?null:String(o);var o;te(this)[e]=r,null===n?this.removeAttribute(t):this.setAttribute(t,n)},configurable:!0,enumerable:!0}}(e,q[e]);Object.defineProperty(Element.prototype,e,t)}const re=p(q);for(let e=0,t=re.length;e<t;e+=1){const t=re[e];J(t)&&ne(t)}Z.lwcRuntimeFlags||Object.defineProperty(Z,"lwcRuntimeFlags",{value:i(null)});const oe=Z.lwcRuntimeFlags;let ie=[];const ae=m(i(null)),se=m([]);function le(){if(0===ie.length)throw new Error("Internal Error: If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue.");const e=ie;ie=[];for(let t=0,n=e.length;t<n;t+=1)e[t]()}function ce(e){if(!R(e))throw new Error("Internal Error: addCallbackToNextTick() can only accept a function callback");0===ie.length&&Promise.resolve().then(le),M.call(ie,e)}const de=/;(?![^(]*\))/g,ue=/:(.+)/,he=new WeakMap;let fe=null;function pe(e,t){const n=he.get(e);if(!D(n)){const e=n[t];if(!D(e))for(let t=0,n=e.length;t<n;t+=1)e[t].notify()}}function me(e,t){if(null===fe)return;const n=fe,r=function(e){let t=he.get(e);if(D(t)){const n=i(null);t=n,he.set(e,n)}return t}(e);let o=r[t];if(D(o))o=[],r[t]=o;else if(o[0]===n)return;-1===b.call(o,n)&&n.link(o)}class ge{constructor(e){this.listeners=[],this.callback=e}observe(e){const t=fe;let n;fe=this;try{e()}catch(e){n=Object(e)}finally{if(fe=t,void 0!==n)throw n}}reset(){const{listeners:e}=this,t=e.length;if(t>0){for(let n=0;n<t;n+=1){const t=e[n],r=b.call(e[n],this);x.call(t,r,1)}e.length=0}}notify(){this.callback.call(void 0,this)}link(e){M.call(e,this),M.call(this.listeners,e)}}function ye(e,t){pe(e.component,t)}function ve(e,t){me(e.component,t)}function we(e){return`<${N.call(e.tagName)}>`}function be(e,t,n){let r=`[LWC ${e}]: ${t}`;D(n)||(r=`${r}\n${function(e){const t=[];let n="";for(;!P(e.owner);)M.call(t,n+we(e)),e=e.owner,n+="\t";return k.call(t,"\n")}(n)}`);try{throw new Error(r)}catch(t){console[e](t)}}function ke(e,t){be("error",e,t)}function $e(e,t){be("warn",e,t)}function Me(e){const{elm:t,data:{on:n},owner:{renderer:r}}=e;if(D(n))return;const o=e.listener=function e(t){!function(e,t){const{type:n}=e,{data:{on:r}}=t,o=r&&r[n];o&&o.call(void 0,e)}(t,e.vnode)};let i;for(i in o.vnode=e,n)r.addEventListener(t,i,o)}var Ce={update:function(e,t){D(e.listener)?Me(t):(t.listener=e.listener,t.listener.vnode=t)},create:Me};function Te(e){return`Using the \`${e}\` property is an anti-pattern because it rounds the value to an integer. Instead, use the \`getBoundingClientRect\` method to obtain fractional values for the size of an element and its position relative to the viewport.`}const Ee=o(i(null),{accessKey:{attribute:"accesskey"},accessKeyLabel:{readOnly:!0},className:{attribute:"class",error:"Using the `className` property is an anti-pattern because of slow runtime behavior and potential conflicts with classes provided by the owner element. Use the `classList` API instead."},contentEditable:{attribute:"contenteditable"},dataset:{readOnly:!0,error:"Using the `dataset` property is an anti-pattern because it can't be statically analyzed. Expose each property individually using the `@api` decorator instead."},dir:{attribute:"dir"},draggable:{attribute:"draggable"},dropzone:{attribute:"dropzone",readOnly:!0},hidden:{attribute:"hidden"},id:{attribute:"id"},inputMode:{attribute:"inputmode"},lang:{attribute:"lang"},slot:{attribute:"slot",error:"Using the `slot` property is an anti-pattern."},spellcheck:{attribute:"spellcheck"},style:{attribute:"style"},tabIndex:{attribute:"tabindex"},title:{attribute:"title"},translate:{attribute:"translate"},isContentEditable:{readOnly:!0},offsetHeight:{readOnly:!0,error:Te("offsetHeight")},offsetLeft:{readOnly:!0,error:Te("offsetLeft")},offsetParent:{readOnly:!0},offsetTop:{readOnly:!0,error:Te("offsetTop")},offsetWidth:{readOnly:!0,error:Te("offsetWidth")},role:{attribute:"role"}});let xe,Se=null;function Le(e,t){return e!==Se||t!==xe}function Oe(e,t){Se=null,xe=void 0}function He(e,t){Se=e,xe=t}function Ae(e,t){const{data:{attrs:n},owner:{renderer:o}}=t;if(D(n))return;let{data:{attrs:i}}=e;if(i===n)return;r.invariant(D(i)||p(i).join(",")===p(n).join(","),"vnode.data.attrs cannot change shape.");const a=t.elm,{setAttribute:s,removeAttribute:l}=o;let c;for(c in i=D(i)?ae:i,n){const e=n[c];i[c]!==e&&(He(a,c),58===H.call(c,3)?s(a,c,e,"http://www.w3.org/XML/1998/namespace"):58===H.call(c,5)?s(a,c,e,"http://www.w3.org/1999/xlink"):P(e)?l(a,c):s(a,c,e),Oe())}}const Ie={data:{}};var Ne={create:e=>Ae(Ie,e),update:Ae};function De(e,t){return"input"===e&&("value"===t||"checked"===t)}function Pe(e,t){const n=t.data.props;if(D(n))return;const o=e.data.props;if(o===n)return;r.invariant(D(o)||p(o).join(",")===p(n).join(","),"vnode.data.props cannot change shape.");const i=D(o),{elm:a,sel:s,owner:{renderer:l}}=t;for(const e in n){const t=n[e];(i||t!==(De(s,e)?l.getProperty(a,e):o[e]))&&l.setProperty(a,e,t)}}const Fe={data:{}};var _e={create:e=>Pe(Fe,e),update:Pe};const Re=i(null);function je(e){if(null==e)return ae;e=B(e)?e:e+"";let t=Re[e];if(t)return t;t=i(null);let n,r=0;const o=e.length;for(n=0;n<o;n++)32===H.call(e,n)&&(n>r&&(t[I.call(e,r,n)]=!0),r=n+1);return n>r&&(t[I.call(e,r,n)]=!0),Re[e]=t,l(t),t}function Be(e,t){const{elm:n,data:{className:r},owner:{renderer:o}}=t,{data:{className:i}}=e;if(i===r)return;const a=o.getClassList(n),s=je(r),l=je(i);let c;for(c in l)D(s[c])&&a.remove(c);for(c in s)D(l[c])&&a.add(c)}const We={data:{}};var Ve={create:e=>Be(We,e),update:Be};function Ge(e,t){const{elm:n,data:{style:r},owner:{renderer:o}}=t,{setAttribute:i,removeAttribute:a}=o;e.data.style!==r&&(B(r)&&""!==r?i(n,"style",r):a(n,"style"))}const Ue={data:{}};var Ke={create:e=>Ge(Ue,e),update:Ge},ze=function(e){const{elm:t,data:{classMap:n},owner:{renderer:r}}=e;if(D(n))return;const o=r.getClassList(t);for(const e in n)o.add(e)},qe=function(e){const{elm:t,data:{styleDecls:n},owner:{renderer:r}}=e;if(!D(n))for(let e=0;e<n.length;e++){const[o,i,a]=n[e];r.setCSSStyleProperty(t,o,i,a)}};function Ze(e,t){return e.key===t.key&&e.sel===t.sel}function Xe(e){return null!=e}function Ye(e,t,n){const r={};let o,i,a;for(o=t;o<=n;++o)a=e[o],Xe(a)&&(i=a.key,void 0!==i&&(r[i]=o));return r}function Qe(e,t,n,r,o){for(;r<=o;++r){const o=n[r];Xe(o)&&(o.hook.create(o),o.hook.insert(o,e,t))}}function Je(e,t,n,r){for(;n<=r;++n){const r=t[n];Xe(r)&&r.hook.remove(r,e)}}function et(e,t,n){let r=0,o=0,i=t.length-1,a=t[0],s=t[i];const l=n.length-1;let c,d,u,h,f=l,p=n[0],m=n[f];for(;r<=i&&o<=f;)Xe(a)?Xe(s)?Xe(p)?Xe(m)?Ze(a,p)?(nt(a,p),a=t[++r],p=n[++o]):Ze(s,m)?(nt(s,m),s=t[--i],m=n[--f]):Ze(a,m)?(nt(a,m),m.hook.move(a,e,s.owner.renderer.nextSibling(s.elm)),a=t[++r],m=n[--f]):Ze(s,p)?(nt(s,p),p.hook.move(s,e,a.elm),s=t[--i],p=n[++o]):(void 0===c&&(c=Ye(t,r,i)),d=c[p.key],void 0===d?(p.hook.create(p),p.hook.insert(p,e,a.elm),p=n[++o]):(u=t[d],Xe(u)&&(u.sel!==p.sel?(p.hook.create(p),p.hook.insert(p,e,a.elm)):(nt(u,p),t[d]=void 0,p.hook.move(u,e,a.elm))),p=n[++o])):m=n[--f]:p=n[++o]:s=t[--i]:a=t[++r];if(r<=i||o<=f)if(r>i){let t,r=f;do{t=n[++r]}while(!Xe(t)&&r<l);h=Xe(t)?t.elm:null,Qe(e,h,n,o,f)}else Je(e,t,r,i)}function tt(e,t,n){const r=t.length,o=n.length;if(0===r)return void Qe(e,null,n,0,o);if(0===o)return void Je(e,t,0,r);let i=null;for(let r=o-1;r>=0;r-=1){const o=n[r],a=t[r];o!==a&&(Xe(a)?Xe(o)?(nt(a,o),i=o.elm):a.hook.remove(a,e):Xe(o)&&(o.hook.create(o),o.hook.insert(o,e,i),i=o.elm))}}function nt(e,t){e!==t&&(t.elm=e.elm,t.hook.update(e,t))}function rt(e){return o({configurable:!0,enumerable:!0,writable:!0},e)}function ot(e){return o({configurable:!0,enumerable:!0},e)}let it=!1;function at(){it=!0}function st(){it=!1}function lt(e,t){return ke(`The \`${e}\` ${t} is available only on elements that use the \`lwc:dom="manual"\` directive.`)}function ct(e){const t=function(e){const t=e.addEventListener,n=U(e,"innerHTML"),r=U(e,"outerHTML"),o=U(e,"textContent");return{innerHTML:ot({get(){return n.get.call(this)},set(e){throw new TypeError("Invalid attempt to set innerHTML on HTMLElement.")}}),outerHTML:ot({get(){return r.get.call(this)},set(e){throw new TypeError("Invalid attempt to set outerHTML on HTMLElement.")}}),textContent:ot({get(){return o.get.call(this)},set(e){throw new TypeError("Invalid attempt to set textContent on HTMLElement.")}}),addEventListener:rt({value(e,n,r){return D(r)||ke("The `addEventListener` method in `LightningElement` does not support any options.",go(this)),t.apply(this,arguments)}})}}(e),n=u(e);g(e,i(n,t))}function dt(e){a(e,{tagName:ot({get(){throw new Error("Usage of property `tagName` is disallowed because the component itself does not know which tagName will be used to create the element, therefore writing code that check for that value is error prone.")},configurable:!0,enumerable:!1})})}const ut="undefined"!=typeof HTMLElement?HTMLElement:function(){},ht=ut.prototype,ft=i(null);L.call(p(q),(e=>{const t=U(ht,e);D(t)||(ft[e]=t)})),L.call(["accessKey","dir","draggable","hidden","id","lang","spellcheck","tabIndex","title"],(e=>{const t=U(ht,e);D(t)||(ft[e]=t)}));const{isArray:pt}=Array,{getPrototypeOf:mt,create:gt,defineProperty:yt,isExtensible:vt,getOwnPropertyDescriptor:wt,getOwnPropertyNames:bt,getOwnPropertySymbols:kt,preventExtensions:$t,hasOwnProperty:Mt}=Object,{push:Ct,concat:Tt}=Array.prototype,Et={}.toString;function xt(e){return void 0===e}function St(e){return"function"==typeof e}const Lt=new WeakMap;function Ot(e,t){Lt.set(e,t)}const Ht=e=>Lt.get(e)||e;class At{constructor(e,t){this.originalTarget=t,this.membrane=e}wrapDescriptor(e){if(Mt.call(e,"value"))e.value=this.wrapValue(e.value);else{const{set:t,get:n}=e;xt(n)||(e.get=this.wrapGetter(n)),xt(t)||(e.set=this.wrapSetter(t))}return e}copyDescriptorIntoShadowTarget(e,t){const{originalTarget:n}=this,r=wt(n,t);if(!xt(r)){const n=this.wrapDescriptor(r);yt(e,t,n)}}lockShadowTarget(e){const{originalTarget:t}=this;Tt.call(bt(t),kt(t)).forEach((t=>{this.copyDescriptorIntoShadowTarget(e,t)}));const{membrane:{tagPropertyKey:n}}=this;xt(n)||Mt.call(e,n)||yt(e,n,gt(null)),$t(e)}apply(e,t,n){}construct(e,t,n){}get(e,t){const{originalTarget:n,membrane:{valueObserved:r}}=this,o=n[t];return r(n,t),this.wrapValue(o)}has(e,t){const{originalTarget:n,membrane:{tagPropertyKey:r,valueObserved:o}}=this;return o(n,t),t in n||t===r}ownKeys(e){const{originalTarget:t,membrane:{tagPropertyKey:n}}=this,r=xt(n)||Mt.call(t,n)?[]:[n];return Ct.apply(r,bt(t)),Ct.apply(r,kt(t)),r}isExtensible(e){const{originalTarget:t}=this;return!(!vt(e)||!vt(t)&&(this.lockShadowTarget(e),1))}getPrototypeOf(e){const{originalTarget:t}=this;return mt(t)}getOwnPropertyDescriptor(e,t){const{originalTarget:n,membrane:{valueObserved:r,tagPropertyKey:o}}=this;r(n,t);let i=wt(n,t);if(xt(i)){if(t!==o)return;return i={value:void 0,writable:!1,configurable:!1,enumerable:!1},yt(e,o,i),i}return!1===i.configurable&&this.copyDescriptorIntoShadowTarget(e,t),this.wrapDescriptor(i)}}const It=new WeakMap,Nt=new WeakMap,Dt=new WeakMap,Pt=new WeakMap;class Ft extends At{wrapValue(e){return this.membrane.getProxy(e)}wrapGetter(e){const t=It.get(e);if(!xt(t))return t;const n=this,r=function(){return n.wrapValue(e.call(Ht(this)))};return It.set(e,r),Dt.set(r,e),r}wrapSetter(e){const t=Nt.get(e);if(!xt(t))return t;const n=function(t){e.call(Ht(this),Ht(t))};return Nt.set(e,n),Pt.set(n,e),n}unwrapDescriptor(e){if(Mt.call(e,"value"))e.value=Ht(e.value);else{const{set:t,get:n}=e;xt(n)||(e.get=this.unwrapGetter(n)),xt(t)||(e.set=this.unwrapSetter(t))}return e}unwrapGetter(e){const t=Dt.get(e);if(!xt(t))return t;const n=this,r=function(){return Ht(e.call(n.wrapValue(this)))};return It.set(r,e),Dt.set(e,r),r}unwrapSetter(e){const t=Pt.get(e);if(!xt(t))return t;const n=this,r=function(t){e.call(n.wrapValue(this),n.wrapValue(t))};return Nt.set(r,e),Pt.set(e,r),r}set(e,t,n){const{originalTarget:r,membrane:{valueMutated:o}}=this;return r[t]!==n?(r[t]=n,o(r,t)):"length"===t&&pt(r)&&o(r,t),!0}deleteProperty(e,t){const{originalTarget:n,membrane:{valueMutated:r}}=this;return delete n[t],r(n,t),!0}setPrototypeOf(e,t){throw new Error(`Invalid setPrototypeOf invocation for reactive proxy ${n=this.originalTarget,n&&n.toString?n.toString():"object"==typeof n?Et.call(n):n+""}. Prototype of reactive objects cannot be changed.`);var n}preventExtensions(e){if(vt(e)){const{originalTarget:t}=this;if($t(t),vt(t))return!1;this.lockShadowTarget(e)}return!0}defineProperty(e,t,n){const{originalTarget:r,membrane:{valueMutated:o,tagPropertyKey:i}}=this;return t===i&&!Mt.call(r,t)||(yt(r,t,this.unwrapDescriptor(n)),!1===n.configurable&&this.copyDescriptorIntoShadowTarget(e,t),o(r,t),!0)}}const _t=new WeakMap,Rt=new WeakMap;class jt extends At{wrapValue(e){return this.membrane.getReadOnlyProxy(e)}wrapGetter(e){const t=_t.get(e);if(!xt(t))return t;const n=this,r=function(){return n.wrapValue(e.call(Ht(this)))};return _t.set(e,r),r}wrapSetter(e){const t=Rt.get(e);if(!xt(t))return t;const n=this,r=function(e){{const{originalTarget:e}=n;throw new Error(`Invalid mutation: Cannot invoke a setter on "${e}". "${e}" is read-only.`)}};return Rt.set(e,r),r}set(e,t,n){{const{originalTarget:e}=this,n=pt(e)?`Invalid mutation: Cannot mutate array at index ${t.toString()}. Array is read-only.`:`Invalid mutation: Cannot set "${t.toString()}" on "${e}". "${e}" is read-only.`;throw new Error(n)}}deleteProperty(e,t){{const{originalTarget:e}=this;throw new Error(`Invalid mutation: Cannot delete "${t.toString()}" on "${e}". "${e}" is read-only.`)}}setPrototypeOf(e,t){{const{originalTarget:e}=this;throw new Error(`Invalid prototype mutation: Cannot set prototype on "${e}". "${e}" prototype is read-only.`)}}preventExtensions(e){{const{originalTarget:e}=this;throw new Error(`Invalid mutation: Cannot preventExtensions on ${e}". "${e} is read-only.`)}}defineProperty(e,t,n){{const{originalTarget:e}=this;throw new Error(`Invalid mutation: Cannot defineProperty "${t.toString()}" on "${e}". "${e}" is read-only.`)}}}function Bt(e){if(pt(e))return e.map((e=>{const t=Ht(e);return t!==e?Bt(t):e}));const t=gt(mt(e)),n=bt(e);return Tt.call(n,kt(e)).reduce(((t,n)=>{const r=e[n],o=Ht(r);return t[n]=o!==r?Bt(o):r,t}),t)}const Wt={header:e=>{const t=Ht(e);return t&&t!==e?["object",{object:Bt(e)}]:null},hasBody:()=>!1,body:()=>null};!function(){const e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==n.g?n.g:{},t=e.devtoolsFormatters||[];Ct.call(t,Wt),e.devtoolsFormatters=t}();const Vt=Object.prototype;function Gt(e){if(null===e)return!1;if("object"!=typeof e)return!1;if(pt(e))return!0;const t=mt(e);return t===Vt||null===t||null===mt(t)}const Ut=(e,t)=>{},Kt=(e,t)=>{},zt=e=>e;function qt(e){return pt(e)?[]:{}}const Zt=Symbol.for("@@lockerLiveValue");const Xt=new class{constructor(e){if(this.valueDistortion=zt,this.valueMutated=Kt,this.valueObserved=Ut,this.valueIsObservable=Gt,this.readOnlyObjectGraph=new WeakMap,this.reactiveObjectGraph=new WeakMap,!xt(e)){const{valueDistortion:t,valueMutated:n,valueObserved:r,valueIsObservable:o,tagPropertyKey:i}=e;this.valueDistortion=St(t)?t:zt,this.valueMutated=St(n)?n:Kt,this.valueObserved=St(r)?r:Ut,this.valueIsObservable=St(o)?o:Gt,this.tagPropertyKey=i}}getProxy(e){const t=Ht(e),n=this.valueDistortion(t);return this.valueIsObservable(n)?this.readOnlyObjectGraph.get(n)===e?e:this.getReactiveHandler(t,n):n}getReadOnlyProxy(e){e=Ht(e);const t=this.valueDistortion(e);return this.valueIsObservable(t)?this.getReadOnlyHandler(e,t):t}unwrapProxy(e){return Ht(e)}getReactiveHandler(e,t){let n=this.reactiveObjectGraph.get(t);if(xt(n)){const r=new Ft(this,t);n=new Proxy(qt(t),r),Ot(n,e),this.reactiveObjectGraph.set(t,n)}return n}getReadOnlyHandler(e,t){let n=this.readOnlyObjectGraph.get(t);if(xt(n)){const r=new jt(this,t);n=new Proxy(qt(t),r),Ot(n,e),this.readOnlyObjectGraph.set(t,n)}return n}}({valueObserved:me,valueMutated:pe,valueDistortion:function(e){return e},tagPropertyKey:Zt});function Yt(e,t){const{get:n,set:o,enumerable:i,configurable:a}=t;if(!R(n))throw r.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${e} definition. Missing the standard getter.`),new TypeError;if(!R(o))throw r.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${e} definition. Missing the standard setter.`),new TypeError;return{enumerable:i,configurable:a,get(){const t=mo(this);if(!Kr(t))return ve(t,e),n.call(t.elm);ke(`The value of property \`${e}\` can't be read from the constructor because the owner component hasn't set the value yet. Instead, use the constructor to set a default value for the property.`,t)},set(t){const n=mo(this);{const o=jr();r.invariant(!Gr,`${o}.render() method has side effects on the state of ${n}.${e}`),r.invariant(!_r,`When updating the template of ${o}, one of the accessors used by the template has side effects on the state of ${n}.${e}`),r.isFalse(Kr(n),`Failed to construct '${we(n)}': The result must not have attributes.`),r.invariant(!j(t)||P(t),`Invalid value "${t}" for "${e}" of ${n}. Value cannot be an object, must be a primitive value.`)}return t!==n.cmpProps[e]&&(n.cmpProps[e]=t,ye(n,e)),o.call(n.elm,t)}}}const Qt=function(){var e;if(P(Ur))throw new ReferenceError("Illegal constructor");const t=Ur,{def:n,elm:r,renderer:o}=t,{bridge:i}=n;null===(e=o.assertInstanceOfHTMLElement)||void 0===e||e.call(o,t.elm,`Component creation requires a DOM element to be associated to ${t}.`);const a=this;if(g(r,i.prototype),t.component=this,1===arguments.length){const{callHook:e,setHook:n,getHook:r}=arguments[0];t.callHook=e,t.setHook=n,t.getHook=r}return this[Zt]=void 0,po(a,t),po(r,t),1===t.renderMode&&Jt(t),ct(r),dt(a),this};function Jt(e){const{elm:t,mode:n,renderer:r,shadowMode:o,def:{ctor:i}}=e,s=r.attachShadow(t,{"$$lwc-synthetic-mode":1===o,delegatesFocus:Boolean(i.delegatesFocus),mode:n});var l;e.cmpRoot=s,po(s,e),a(l=s,function(e){const t=e.addEventListener,n=U(e,"innerHTML"),r=U(e,"textContent");return{innerHTML:ot({get(){return n.get.call(this)},set(e){throw new TypeError("Invalid attempt to set innerHTML on ShadowRoot.")}}),textContent:ot({get(){return r.get.call(this)},set(e){throw new TypeError("Invalid attempt to set textContent on ShadowRoot.")}}),addEventListener:rt({value(e,n,r){return D(r)||ke("The `addEventListener` method on ShadowRoot does not support any options.",go(this)),t.apply(this,arguments)}})}}(l))}function en(e,t){Kr(e)&&ke(`this.${t} should not be called during the construction of the custom element for ${we(e)} because the element is not yet in the DOM or has no children yet.`)}Qt.prototype={constructor:Qt,dispatchEvent(e){const{elm:t,renderer:{dispatchEvent:n}}=mo(this);return n(t,e)},addEventListener(e,t,n){const o=mo(this),{elm:i,renderer:{addEventListener:a}}=o;{const n=jr();r.invariant(!Gr,`${n}.render() method has side effects on the state of ${o} by adding an event listener for "${e}".`),r.invariant(!_r,`Updating the template of ${n} has side effects on the state of ${o} by adding an event listener for "${e}".`),r.invariant(R(t),`Invalid second argument for this.addEventListener() in ${o} for event "${e}". Expected an EventListener but received ${t}.`)}a(i,e,Jr(o,t),n)},removeEventListener(e,t,n){const r=mo(this),{elm:o,renderer:{removeEventListener:i}}=r;i(o,e,Jr(r,t),n)},hasAttribute(e){const{elm:t,renderer:{getAttribute:n}}=mo(this);return!P(n(t,e))},hasAttributeNS(e,t){const{elm:n,renderer:{getAttribute:r}}=mo(this);return!P(r(n,t,e))},removeAttribute(e){const{elm:t,renderer:{removeAttribute:n}}=mo(this);He(t,e),n(t,e),Oe()},removeAttributeNS(e,t){const{elm:n,renderer:{removeAttribute:r}}=mo(this);He(n,t),r(n,t,e),Oe()},getAttribute(e){const{elm:t,renderer:{getAttribute:n}}=mo(this);return n(t,e)},getAttributeNS(e,t){const{elm:n,renderer:{getAttribute:r}}=mo(this);return r(n,t,e)},setAttribute(e,t){const n=mo(this),{elm:o,renderer:{setAttribute:i}}=n;r.isFalse(Kr(n),`Failed to construct '${we(n)}': The result must not have attributes.`),He(o,e),i(o,e,t),Oe()},setAttributeNS(e,t,n){const o=mo(this),{elm:i,renderer:{setAttribute:a}}=o;r.isFalse(Kr(o),`Failed to construct '${we(o)}': The result must not have attributes.`),He(i,t),a(i,t,n,e),Oe()},getBoundingClientRect(){const e=mo(this),{elm:t,renderer:{getBoundingClientRect:n}}=e;return en(e,"getBoundingClientRect()"),n(t)},get isConnected(){const{elm:e,renderer:{isConnected:t}}=mo(this);return t(e)},get classList(){const e=mo(this),{elm:t,renderer:{getClassList:n}}=e;return r.isFalse(Kr(e),`Failed to construct ${e}: The result must not have attributes. Adding or tampering with classname in constructor is not allowed in a web component, use connectedCallback() instead.`),n(t)},get template(){const e=mo(this);return 0===e.renderMode&&ke("`this.template` returns null for light DOM components. Since there is no shadow, the rendered content can be accessed via `this` itself. e.g. instead of `this.template.querySelector`, use `this.querySelector`."),e.cmpRoot},get shadowRoot(){return null},render(){return mo(this).def.template},toString(){return`[object ${mo(this).def.name}]`}};const tn=i(null),nn=[["children","getChildren"],["childNodes","getChildNodes"],["firstChild","getFirstChild"],["firstElementChild","getFirstElementChild"],["lastChild","getLastChild"],["lastElementChild","getLastElementChild"]];for(const[e,t]of nn)tn[e]={get(){const n=mo(this),{elm:r,renderer:o}=n;return en(n,e),o[t](r)},configurable:!0,enumerable:!0};const rn=["getElementsByClassName","getElementsByTagName","querySelector","querySelectorAll"];for(const e of rn)tn[e]={value(t){const n=mo(this),{elm:r,renderer:o}=n;return en(n,`${e}()`),o[e](r,t)},configurable:!0,enumerable:!0,writable:!0};a(Qt.prototype,tn);const on=i(null);for(const e in ft)on[e]=Yt(e,ft[e]);var an;function sn(e){return{get(){const t=mo(this);return ve(t,e),t.cmpFields[e]},set(t){const n=mo(this);t!==n.cmpFields[e]&&(n.cmpFields[e]=t,ye(n,e))},enumerable:!0,configurable:!0}}function ln(e){return{get(){const t=mo(this);return ve(t,e),t.cmpFields[e]},set(t){const n=mo(this);{const t=jr();r.invariant(!Gr,`${t}.render() method has side effects on the state of ${n}.${G(e)}`),r.invariant(!_r,`Updating the template of ${t} has side effects on the state of ${n}.${G(e)}`)}const o=Xt.getProxy(t);o!==n.cmpFields[e]&&(n.cmpFields[e]=o,ye(n,e))},enumerable:!0,configurable:!0}}function cn(e){return{get(){const t=mo(this);if(!Kr(t))return ve(t,e),t.cmpProps[e];ke(`Can’t read the value of property \`${G(e)}\` from the constructor because the owner component hasn’t set the value yet. Instead, use the constructor to set a default value for the property.`,t)},set(t){const n=mo(this);{const t=jr();r.invariant(!Gr,`${t}.render() method has side effects on the state of ${n}.${G(e)}`),r.invariant(!_r,`Updating the template of ${t} has side effects on the state of ${n}.${G(e)}`)}n.cmpProps[e]=t,ye(n,e)},enumerable:!0,configurable:!0}}a(Qt.prototype,on),s(Qt,"CustomElementConstructor",{get(){throw new ReferenceError("The current runtime does not support CustomElementConstructor.")},configurable:!0}),a(an=Qt.prototype,function(e){const t=e.dispatchEvent,n={dispatchEvent:rt({value(e){const n=mo(this);if(!P(e)&&j(e)){const{type:t}=e;/^[a-z][a-z0-9_]*$/.test(t)||ke(`Invalid event type "${t}" dispatched in element ${we(n)}. Event name must start with a lowercase letter and followed only lowercase letters, numbers, and underscores`,n)}return t.apply(this,arguments)}})};return L.call(d(Ee),(t=>{t in e||(n[t]=ot({get(){const{error:e,attribute:n}=Ee[t],r=[];r.push(`Accessing the global HTML property "${t}" is disabled.`),e?r.push(e):n&&r.push(`Instead access it via \`this.getAttribute("${n}")\`.`),ke(r.join("\n"),mo(this))},set(){const{readOnly:e}=Ee[t];e&&ke(`The global HTML property \`${t}\` is read-only.`,mo(this))}}))})),n}(an));class dn extends ge{constructor(e,t){super((()=>{_(this.debouncing)&&(this.debouncing=!0,ce((()=>{if(F(this.debouncing)){const{value:n}=this,{isDirty:r,component:o,idx:i}=e;t.call(o,n),this.debouncing=!1,F(e.isDirty)&&_(r)&&i>0&&so(e)}})))})),this.debouncing=!1}reset(e){super.reset(),this.debouncing=!1,arguments.length>0&&(this.value=e)}}function un(e,t){const{get:n,set:o,enumerable:i,configurable:a}=t;if(!R(n))throw r.invariant(R(n),`Invalid compiler output for public accessor ${G(e)} decorated with @api`),new Error;return{get(){return mo(this),n.call(this)},set(t){const n=mo(this);{const t=jr();r.invariant(!Gr,`${t}.render() method has side effects on the state of ${n}.${G(e)}`),r.invariant(!_r,`Updating the template of ${t} has side effects on the state of ${n}.${G(e)}`)}if(o)if(oe.ENABLE_REACTIVE_SETTER){let r=n.oar[e];D(r)&&(r=n.oar[e]=new dn(n,o)),r.reset(t),r.observe((()=>{o.call(this,t)}))}else o.call(this,t);else r.fail(`Invalid attempt to set a new value for property ${G(e)} of ${n} that does not has a setter decorated with @api.`)},enumerable:i,configurable:a}}function hn(e){return{get(){const t=mo(this);return ve(t,e),t.cmpFields[e]},set(t){const n=mo(this);t!==n.cmpFields[e]&&(n.cmpFields[e]=t,ye(n,e))},enumerable:!0,configurable:!0}}function fn(e){return R(e.value)?"method":R(e.set)||R(e.get)?"accessor":"field"}function pn(e,t,n){if(!D(n)){const e=fn(n),o=`Invalid observed ${t} field. Found a duplicate ${e} with the same name.`;"accessor"===e?ke(o):r.fail(o)}}function mn(e,t,n){if(!D(n)){const e=fn(n);r.fail(`Invalid @track ${t} field. Found a duplicate ${e} with the same name.`)}}function gn(e,t,n){if(!D(n)){const e=fn(n);r.fail(`Invalid @wire ${t} field. Found a duplicate ${e} with the same name.`)}}function yn(e,t,n){(D(n)||!R(n.value)||_(n.writable))&&r.fail(`Invalid @wire ${t} method.`)}function vn(e,t,n){if(!D(n)){const e=fn(n),o=`Invalid @api ${t} field. Found a duplicate ${e} with the same name.`;"accessor"===e?ke(o):r.fail(o)}}function wn(e,t,n){D(n)?r.fail(`Invalid @api get ${t} accessor.`):R(n.set)?r.isTrue(R(n.get),`Missing getter for property ${t} decorated with @api in ${e}. You cannot have a setter without the corresponding getter.`):R(n.get)||r.fail(`Missing @api get ${t} accessor.`)}const bn=new Map,kn={apiMethods:ae,apiFields:ae,apiFieldsConfig:ae,wiredMethods:ae,wiredFields:ae,observedFields:ae},$n=new Set;function Mn(){return[]}$n.add(Mn);const Cn=i(null),Tn=i(null);function En(e){let t=Cn[e];return D(t)&&(t=Cn[e]=function(){const t=mo(this),{getHook:n}=t;return n(t.component,e)}),t}function xn(e){let t=Tn[e];return D(t)&&(t=Tn[e]=function(t){const n=mo(this),{setHook:r}=n;t=Xt.getReadOnlyProxy(t),r(n.component,e,t)}),t}function Sn(e){return function(){const t=mo(this),{callHook:n,component:r}=t,o=r[e];return n(t.component,o,E.call(arguments))}}function Ln(e,t){return function(n,r,o){if(r===o)return;const i=e[n];D(i)?D(t)||t.apply(this,arguments):Le(this,n)&&(this[i]=o)}}function On(e,t,n){let r;R(e)?r=class extends e{}:(r=function(){throw new TypeError("Illegal constructor")},g(r,e),g(r.prototype,e.prototype),s(r.prototype,"constructor",{writable:!0,configurable:!0,value:r}));const o=i(null),{attributeChangedCallback:l}=e.prototype,{observedAttributes:c=[]}=e,d=i(null);for(let e=0,n=t.length;e<n;e+=1){const n=t[e];o[Q(n)]=n,d[n]={get:En(n),set:xn(n),enumerable:!0,configurable:!0}}for(let e=0,t=n.length;e<t;e+=1){const t=n[e];d[t]={value:Sn(t),writable:!0,configurable:!0}}return d.attributeChangedCallback={value:Ln(o,l)},s(r,"observedAttributes",{get:()=>[...c,...p(o)]}),a(r.prototype,d),r}const Hn=On(ut,d(ft),[]);function An(e){const t=e();return(null==t?void 0:t.__esModule)?t.default:t}function In(e){return R(e)&&h.call(e,"__circular__")}l(Hn),m(Hn.prototype);const Nn=new WeakMap,Dn=new WeakMap,Pn=new WeakMap,Fn=new WeakMap,_n=new WeakMap,Rn=new WeakMap;function jn(e){const t=[];for(const n of e)Array.isArray(n)?t.push(...jn(n)):t.push(n);return t}function Bn(e){if(oe.ENABLE_HMR){const t=new Set;for(;Pn.has(e)&&!t.has(e);)t.add(e),e=Pn.get(e)}return e}const Wn=new WeakMap;function Vn(e){if(!R(e))return!1;if(e.prototype instanceof Qt)return!0;let t=e;do{if(In(t)){const e=An(t);if(e===t)return!0;t=e}if(t===Qt)return!0}while(!P(t)&&(t=u(t)));return!1}function Gn(e){e=function(e){if(oe.ENABLE_HMR){const t=new Set;for(;Dn.has(e)&&!t.has(e);)t.add(e),e=Dn.get(e)}return e}(e);let t=Wn.get(e);if(D(t)){if(In(e))return t=Gn(An(e)),Wn.set(e,t),t;if(!Vn(e))throw new TypeError(`${e} is not a valid component, or does not extends LightningElement from "lwc". You probably forgot to add the extend clause on the class declaration.`);t=function(e){const{shadowSupportMode:t,renderMode:n}=e;{const o=e.name;r.isTrue(e.constructor,`Missing ${o}.constructor, ${o} should have a "constructor" property.`),oe.ENABLE_MIXED_SHADOW_MODE||r.isFalse("shadowSupportMode"in e,`${o||"Anonymous class"} is an invalid LWC component. The shadowSupportMode static property is not available in this environment.`),D(t)||r.invariant("any"===t||"reset"===t,`Invalid value for static property shadowSupportMode: '${t}'`),D(n)||r.invariant("light"===n||"shadow"===n,`Invalid value for static property renderMode: '${n}'. renderMode must be either 'light' or 'shadow'.`)}const s=function(e){const t=bn.get(e);return D(t)?kn:t}(e),{apiFields:c,apiFieldsConfig:d,apiMethods:h,wiredFields:f,wiredMethods:m,observedFields:g}=s,y=e.prototype;let{connectedCallback:v,disconnectedCallback:w,renderedCallback:b,errorCallback:k,render:$}=y;const M=function(e){let t=u(e);if(P(t))throw new ReferenceError(`Invalid prototype chain for ${e.name}, you must extend LightningElement.`);if(In(t)){const n=An(t);if(P(n))throw new ReferenceError(`Circular module dependency for ${e.name}, must resolve to a constructor that extends LightningElement.`);t=n===t?Qt:n}return t}(e),C=M!==Qt?Gn(M):Un,T=On(C.bridge,p(c),p(h)),E=o(i(null),C.props,c),x=o(i(null),C.propsConfig,d),S=o(i(null),C.methods,h),L=o(i(null),C.wire,f,m);v=v||C.connectedCallback,w=w||C.disconnectedCallback,b=b||C.renderedCallback,k=k||C.errorCallback,$=$||C.render;let O=C.shadowSupportMode;D(t)||(O=t);let H=C.renderMode;D(n)||(H="light"===n?0:1);const A=function(e){return Zr.get(e)}(e)||C.template,I=e.name||C.name;a(y,g);const N={ctor:e,name:I,wire:L,props:E,propsConfig:x,methods:S,bridge:T,template:A,renderMode:H,shadowSupportMode:O,connectedCallback:v,disconnectedCallback:w,renderedCallback:b,errorCallback:k,render:$};return l(e.prototype),N}(e),Wn.set(e,t)}return t}const Un={ctor:Qt,name:Qt.name,props:on,propsConfig:ae,methods:ae,renderMode:1,shadowSupportMode:"reset",wire:ae,bridge:Hn,template:Mn,render:Qt.prototype.render};function Kn(e,t){e.$shadowToken$=t}function zn(e,t){const{cmpTemplate:n,context:r}=t,o=null==n?void 0:n.stylesheetToken;!D(o)&&r.hasScopedStyles&&t.renderer.getClassList(e).add(o)}function qn(e,t){const{elm:n,text:r,owner:{renderer:o}}=t;e.text!==r&&(at(),o.setText(n,r),st())}function Zn(e,t,n){const{renderer:r}=e.owner;at(),r.insert(e.elm,t,n),st()}function Xn(e,t){const{renderer:n}=e.owner;at(),n.remove(e.elm,t),st()}function Yn(e){Ce.create(e),_e.create(e)}function Qn(e,t){const{children:n,owner:r}=t,o=sr(n)?et:tt;xo(r,r.owner,W,(()=>{o(t.elm,e.children,n)}),W)}function Jn(e,t){const n=e.aChildren||e.children;t.aChildren=n;const{renderMode:r,shadowMode:o}=t;1!==o&&0!==r||(function(e,t){const{cmpSlots:n}=e,r=e.cmpSlots=i(null);for(let e=0,n=t.length;e<n;e+=1){const n=t[e];if(P(n))continue;const{data:o}=n,i=o.attrs&&o.attrs.slot||"",a=r[i]=r[i]||[];D(n.key)||(n.key=`@${i}:${n.key}`),M.call(a,n)}if(_(e.isDirty)){const t=p(n);if(t.length!==p(r).length)return void Yr(e);for(let o=0,i=t.length;o<i;o+=1){const i=t[o];if(D(r[i])||n[i].length!==r[i].length)return void Yr(e);const a=n[i],s=r[i];for(let t=0,n=r[i].length;t<n;t+=1)if(a[t]!==s[t])return void Yr(e)}}}(t,n),e.aChildren=n,e.children=se)}function er(e){const{elm:t,children:n}=e;for(let e=0;e<n.length;++e){const r=n[e];null!=r&&(r.hook.create(r),r.hook.insert(r,t,null))}}function tr(e,t){const{data:{attrs:n={}},owner:{renderer:r}}=e;let o=!0;for(const[i,a]of Object.entries(n)){const n=r.getAttribute(t,i);String(a)!==n&&(ke(`Mismatch hydrating element <${t.tagName.toLowerCase()}>: attribute "${i}" has different values, expected "${a}" but found "${n}"`,e.owner),o=!1)}return o}function nr(e,t){const{data:{className:n,classMap:r},owner:{renderer:o}}=e;let i,a=!0;if(D(n)||String(n)===t.className){if(!D(r)){const e=o.getClassList(t);let n="";for(const t in r)n+=" "+t,e.contains(t)||(a=!1);i=n.trim(),e.length>p(r).length&&(a=!1)}}else a=!1,i=n;return a||ke(`Mismatch hydrating element <${t.tagName.toLowerCase()}>: attribute "class" has different values, expected "${i}" but found "${t.className}"`,e.owner),a}function rr(e,t){const{data:{style:n,styleDecls:r},owner:{renderer:o}}=e,i=o.getAttribute(t,"style")||"";let a,s=!0;if(D(n)||n===i){if(!D(r)){const e=function(e){const t={},n=e.split(de);for(const e of n)if(e){const[n,r]=e.split(ue);void 0!==n&&void 0!==r&&(t[n.trim()]=r.trim())}return t}(i),t=[];for(let n=0,o=r.length;n<o;n++){const[o,i,a]=r[n];t.push(`${o}: ${i+(a?" important!":"")}`);const l=e[o];D(l)?s=!1:l.startsWith(i)?a&&!l.endsWith("!important")&&(s=!1):s=!1}p(e).length>r.length&&(s=!1),a=k.call(t,";")}}else s=!1,a=n;return s||ke(`Mismatch hydrating element <${t.tagName.toLowerCase()}>: attribute "style" has different values, expected "${a}" but found "${i}".`,e.owner),s}function or(){r.fail("Server rendered elements do not match client side generated elements")}function ir(e,t,n){var r,o;{const r=v.call(t,(e=>!!e));e.length!==r.length&&(ke(`Hydration mismatch: incorrect number of rendered nodes, expected ${r.length} but found ${e.length}.`,n),or())}let i=0;for(let a=0,s=t.length;a<s;a++){const s=t[a];if(null!=s){const t=e[i];if(t.nodeType===Node.ELEMENT_NODE){(null===(r=s.sel)||void 0===r?void 0:r.toLowerCase())!==t.tagName.toLowerCase()&&(ke(`Hydration mismatch: expecting element with tag "${null===(o=s.sel)||void 0===o?void 0:o.toLowerCase()}" but found "${t.tagName.toLowerCase()}".`,n),or());const e=tr(s,t),i=nr(s,t),a=rr(s,t);e&&i&&a||or()}s.hook.hydrate(s,t),i++}}}const ar=new WeakMap;function sr(e){return ar.has(e)}function lr(e,t){e=e.toLowerCase();let n=t.getCustomElement(e);return D(n)?(n=class extends t.HTMLElement{constructor(e){super(),R(e)&&e(this)}},t.defineCustomElement(e,n),n):n}const cr=Symbol.iterator,dr={create:e=>{const{owner:t}=e,{renderer:n}=t,r=n.createText(e.text);pr(r,t),e.elm=r},update:qn,insert:Zn,move:Zn,remove:Xn,hydrate:(e,t)=>{var n;t.nodeType!==Node.TEXT_NODE&&(ke("Hydration mismatch: incorrect node type received",e.owner),r.fail("Hydration mismatch: incorrect node type received.")),t.nodeValue!==e.text&&$e("Hydration mismatch: text values do not match, will recover from the difference",e.owner),t.nodeValue=null!==(n=e.text)&&void 0!==n?n:null,e.elm=t}},ur={create:e=>{const{owner:t,text:n}=e,{renderer:r}=t,o=r.createComment(n);pr(o,t),e.elm=o},update:qn,insert:Zn,move:Zn,remove:Xn,hydrate:(e,t)=>{var n;t.nodeType!==Node.COMMENT_NODE&&(ke("Hydration mismatch: incorrect node type received",e.owner),r.fail("Hydration mismatch: incorrect node type received.")),t.nodeValue!==e.text&&$e("Hydration mismatch: comment values do not match, will recover from the difference",e.owner),t.nodeValue=null!==(n=e.text)&&void 0!==n?n:null,e.elm=t}},hr={create:e=>{const{sel:t,owner:n,data:{svg:r}}=e,{renderer:i}=n,s=F(r)?"http://www.w3.org/2000/svg":void 0,l=i.createElement(t,s);pr(l,n),function(e,t){const{owner:n}=t;if(zn(e,n),1===n.shadowMode){const{data:{context:r}}=t,{stylesheetToken:o}=n.context;D(r)||D(r.lwc)||"manual"!==r.lwc.dom||function(e){e.$domManual$=!0}(e),Kn(e,o)}{const{data:{context:r}}=t;!function(e,t){const n=U(e,"outerHTML"),r={outerHTML:ot({get(){return n.get.call(this)},set(e){throw new TypeError("Invalid attempt to set outerHTML on Element.")}})};if(!t.isLight&&!t.isPortal){const{appendChild:t,insertBefore:n,removeChild:i,replaceChild:a}=e,s=U(e,"nodeValue"),l=U(e,"innerHTML"),c=U(e,"textContent");o(r,{appendChild:rt({value(e){return lt("appendChild","method"),t.call(this,e)}}),insertBefore:rt({value(e,t){return it||lt("insertBefore","method"),n.call(this,e,t)}}),removeChild:rt({value(e){return it||lt("removeChild","method"),i.call(this,e)}}),replaceChild:rt({value(e,t){return lt("replaceChild","method"),a.call(this,e,t)}}),nodeValue:ot({get(){return s.get.call(this)},set(e){it||lt("nodeValue","property"),s.set.call(this,e)}}),textContent:ot({get(){return c.get.call(this)},set(e){lt("textContent","property"),c.set.call(this,e)}}),innerHTML:ot({get(){return l.get.call(this)},set(e){return lt("innerHTML","property"),l.set.call(this,e)}})})}a(e,r)}(e,{isPortal:!D(r)&&!D(r.lwc)&&"manual"===r.lwc.dom,isLight:0===n.renderMode})}}(l,e),e.elm=l,function(e){Ce.create(e),Ne.create(e),_e.create(e),ze(e),qe(e),Ve.create(e),Ke.create(e)}(e)},update:(e,t)=>{!function(e,t){Ne.update(e,t),_e.update(e,t),Ve.update(e,t),Ke.update(e,t)}(e,t),Qn(e,t)},insert:(e,t,n)=>{Zn(e,t,n),er(e)},move:(e,t,n)=>{Zn(e,t,n)},remove:(e,t)=>{Xn(e,t),function(e){const{children:t,elm:n}=e;for(let e=0,r=t.length;e<r;++e){const r=t[e];P(r)||r.hook.remove(r,n)}}(e)},hydrate:(e,t)=>{const n=t;e.elm=n;const{context:r}=e.data,o=Boolean(!D(r)&&!D(r.lwc)&&"manual"===r.lwc.dom);if(o){const{props:t}=e.data;D(t)||D(t.innerHTML)||(n.innerHTML===t.innerHTML?delete t.innerHTML:$e(`Mismatch hydrating element <${n.tagName.toLowerCase()}>: innerHTML values do not match for element, will recover from the difference`,e.owner))}Yn(e),o||ir(e.elm.childNodes,e.children,e.owner)}},fr={create:e=>{const{sel:t,owner:n}=e,{renderer:o}=n,i=lr(t,o),a=new i((t=>{!function(e,t){if(!D(go(e)))return;const{sel:n,mode:o,ctor:i,owner:a}=t;if(zn(e,a),1===a.shadowMode){const{stylesheetToken:t}=a.context;Kn(e,t)}ho(e,Gn(i),{mode:o,owner:a,tagName:n,renderer:a.renderer}),r.isTrue(y(t.children),"Invalid vnode for a custom element, it must have children defined.")}(t,e)}));pr(a,n),e.elm=a;const s=go(a);if(s)Jn(e,s);else if(e.ctor!==i)throw new TypeError("Incorrect Component Constructor");!function(e){Ce.create(e),Ne.create(e),_e.create(e),ze(e),qe(e),Ve.create(e),Ke.create(e)}(e)},update:(e,t)=>{!function(e,t){Ne.update(e,t),_e.update(e,t),Ve.update(e,t),Ke.update(e,t)}(e,t);const n=go(t.elm);n&&Jn(t,n),Qn(e,t),n&&(r.isTrue(y(t.children),"Invalid vnode for a custom element, it must have children defined."),so(n))},insert:(e,t,n)=>{Zn(e,t,n);const o=go(e.elm);o&&(r.isTrue(0===o.state,`${o} cannot be recycled.`),ko(o)),er(e),o&&function(e){yo(e)}(o)},move:(e,t,n)=>{Zn(e,t,n)},remove:(e,t)=>{Xn(e,t);const n=go(e.elm);n&&function(e){r.isTrue(1===e.state||2===e.state,`${e} must have been connected.`),uo(e)}(n)},hydrate:(e,t)=>{const{sel:n,mode:o,ctor:i,owner:a}=e;ho(t,Gn(i),{mode:o,owner:a,tagName:n,renderer:a.renderer}),e.elm=t;const s=mo(t);Jn(e,s),Yn(e),r.isTrue(0===s.state,`${s} cannot be recycled.`),ko(s),0!==s.renderMode&&ir(e.elm.childNodes,e.children,s),function(e){!function(e){if(F(e.isDirty)){const t=Xr(e);e.children=t,ir(0===e.renderMode?e.elm.childNodes:e.elm.shadowRoot.childNodes,t,e),vo(e)}}(e)}(s)}};function pr(e,t){const{renderer:n,renderMode:r,shadowMode:o}=t;n.isSyntheticShadowDefined&&(1!==o&&0!==r||(e.$shadowResolver$=So(t).$shadowResolver$))}function mr(e){M.call(jr().velements,e)}function gr(e,t,n){const o=jr();r.isTrue(B(e),"h() 1st argument sel must be a string."),r.isTrue(j(t),"h() 2nd argument data must be an object."),r.isTrue(y(n),"h() 3rd argument children must be an array."),r.isTrue("key"in t,` <${e}> "key" attribute is invalid or missing for ${o}. Key inside iterator is either undefined or null.`),r.isFalse(t.className&&t.classMap,"vnode.data.className and vnode.data.classMap ambiguous declaration."),r.isFalse(t.styleDecls&&t.style,"vnode.data.styleDecls and vnode.data.style ambiguous declaration."),t.style&&!B(t.style)&&ke(`Invalid 'style' attribute passed to <${e}> is ignored. This attribute must be a string value.`,o),L.call(n,(e=>{null!=e&&r.isTrue(e&&"sel"in e&&"data"in e&&"children"in e&&"text"in e&&"elm"in e&&"key"in e,`${e} is not a vnode.`)}));const{key:i}=t;return{sel:e,data:t,children:n,text:void 0,elm:void 0,key:i,hook:hr,owner:o}}function yr(e,t,n,o=se){const i=jr();r.isTrue(B(e),"c() 1st argument sel must be a string."),r.isTrue(R(t),"c() 2nd argument Ctor must be a function."),r.isTrue(j(n),"c() 3nd argument data must be an object."),r.isTrue(3===arguments.length||y(o),"c() 4nd argument data must be an array."),r.isFalse(n.className&&n.classMap,"vnode.data.className and vnode.data.classMap ambiguous declaration."),r.isFalse(n.styleDecls&&n.style,"vnode.data.styleDecls and vnode.data.style ambiguous declaration."),n.style&&!B(n.style)&&ke(`Invalid 'style' attribute passed to <${e}> is ignored. This attribute must be a string value.`,i),4===arguments.length&&L.call(o,(e=>{null!=e&&r.isTrue(e&&"sel"in e&&"data"in e&&"children"in e&&"text"in e&&"elm"in e&&"key"in e,`${e} is not a vnode.`)}));const{key:a}=n;let s,l;const c={sel:e,data:n,children:o,text:s,elm:l,key:a,hook:fr,ctor:t,owner:i,mode:"open"};return mr(c),c}const vr=new Map;let wr=0;function br(e){var t;return r.isTrue(y(e),"sc() api can only work with arrays."),t=e,ar.set(t,1),e}const kr=l({s:function(e,t,n,o){r.isTrue(B(e),"s() 1st argument slotName must be a string."),r.isTrue(j(t),"s() 2nd argument data must be an object."),r.isTrue(y(n),"h() 3rd argument children must be an array."),D(o)||D(o[e])||0===o[e].length||(n=o[e]);const i=jr(),{renderMode:a,shadowMode:s}=i;return 0===a?(br(n),n):(1===s&&br(n),gr("slot",t,n))},h:gr,c:yr,i:function(e,t){const n=[];br(n);const o=jr();if(D(e)||null===e)return ke(`Invalid template iteration for value "${G(e)}" in ${o}. It must be an Array or an iterable Object.`,o),n;r.isFalse(D(e[cr]),`Invalid template iteration for value \`${G(e)}\` in ${o}. It must be an array-like object and not \`null\` nor \`undefined\`.`);const a=e[cr]();r.isTrue(a&&R(a.next),`Invalid iterator function for "${G(e)}" in ${o}.`);let s,l,c=a.next(),d=0,{value:u,done:h}=c;for(s=i(null);!1===h;){c=a.next(),h=c.done;const e=t(u,d,0===d,!0===h);y(e)?M.apply(n,e):M.call(n,e);{const t=y(e)?e:[e];L.call(t,(e=>{if(!P(e)&&j(e)&&!D(e.sel)){const{key:t}=e;B(t)||"number"==typeof t?(1===s[t]&&D(l)&&(l=`Duplicated "key" attribute value for "<${e.sel}>" in ${o} for item number ${d}. A key with value "${e.key}" appears more than once in the iteration. Key values must be unique numbers or strings.`),s[t]=1):D(l)&&(l=`Invalid "key" attribute value in "<${e.sel}>" in ${o} for item number ${d}. Set a unique "key" value on all iterated child elements.`)}}))}d+=1,u=c.value}return D(l)||ke(l,o),n},f:function(e){r.isTrue(y(e),"flattening api can only work with arrays.");const t=e.length,n=[];br(n);for(let r=0;r<t;r+=1){const t=e[r];y(t)?M.apply(n,t):M.call(n,t)}return n},t:function(e){return{sel:void 0,data:ae,children:void 0,text:e,elm:void 0,key:void 0,hook:dr,owner:jr()}},d:function(e){return null==e?"":String(e)},b:function(e){const t=jr();if(P(t))throw new Error;const n=t;return function(t){qr(n,e,n.component,t)}},k:function(e,t){switch(typeof t){case"number":case"string":return e+":"+t;case"object":r.fail(`Invalid key value "${t}" in ${jr()}. Key must be a string or number.`)}},co:function(e){return{sel:void 0,data:ae,children:void 0,text:e,elm:void 0,key:void 0,hook:ur,owner:jr()}},dc:function(e,t,n,o){if(r.isTrue(B(e),"dc() 1st argument sel must be a string."),r.isTrue(j(n),"dc() 3nd argument data must be an object."),r.isTrue(3===arguments.length||y(o),"dc() 4nd argument data must be an array."),null==t)return null;if(!Vn(t))throw new Error(`Invalid LWC Constructor ${G(t)} for custom element <${e}>.`);let i=vr.get(t);return D(i)&&(i=wr++,vr.set(t,i)),n.key=`dc:${i}:${n.key}`,yr(e,t,n,o)},ti:function(e){const t=e>0&&!(F(e)||_(e));{const n=jr();t&&ke(`Invalid tabindex value \`${G(e)}\` in template for ${n}. This attribute must be set to 0 or -1.`,n)}return t?0:e},gid:function(e){const t=jr();if(D(e)||""===e)return ke(`Invalid id value "${e}". The id attribute must contain a non-empty string.`,t),e;if(P(e))return null;const{idx:n,shadowMode:r}=t;return 1===r?A.call(e,/\S+/g,(e=>`${e}-${n}`)):e},fid:function(e){const t=jr();if(D(e)||""===e)return D(e)&&ke('Undefined url value for "href" or "xlink:href" attribute. Expected a non-empty string.',t),e;if(P(e))return null;const{idx:n,shadowMode:r}=t;return 1===r&&/^#/.test(e)?`${e}-${n}`:e},shc:function(e){return(()=>{throw new Error("sanitizeHtmlContent hook must be implemented.")})()}});function $r(e){return`${e}-host`}function Mr(e,t,n){const r=[];for(let o=0;o<e.length;o++){let i=e[o];if(y(i))M.apply(r,Mr(i,t,n));else{i=Bn(i);const e=i.$scoped$,o=0===n.renderMode?!e:0===n.shadowMode,a=e||1===n.shadowMode&&1===n.renderMode?t:void 0;M.call(r,i(o,a))}}return r}function Cr(e,t){const{stylesheets:n,stylesheetToken:r}=t;let o=[];return D(n)||0===n.length||(o=Mr(n,r,e)),o}const Tr=["constructor","render","patch","connectedCallback","renderedCallback","disconnectedCallback","errorCallback","lwc-hydrate","lwc-rehydrate"],Er="undefined"!=typeof performance&&"function"==typeof performance.mark&&"function"==typeof performance.clearMarks&&"function"==typeof performance.measure&&"function"==typeof performance.clearMeasures,xr=Er?e=>{performance.mark(e)}:W,Sr=Er?(e,t)=>{performance.measure(e,t),performance.clearMarks(t),performance.clearMeasures(e)}:W;function Lr(e){return Tr[e]}function Or(e,t){return`${we(t)} - ${Lr(e)}`}function Hr(e,t){return`${Or(e,t)} - ${t.idx}`}let Ar=!1,Ir=W;function Nr(e,t){{const n=Hr(e,t);xr(n)}Ar&&Ir(e,0,t.tagName,t.idx)}function Dr(e,t){{const n=Hr(e,t),r=Or(e,t);Sr(r,n)}Ar&&Ir(e,1,t.tagName,t.idx)}function Pr(e,t){{const n=Lr(e),r=D(t)?n:Hr(e,t);xr(r)}Ar&&Ir(e,0,null==t?void 0:t.tagName,null==t?void 0:t.idx)}function Fr(e,t){{const n=Lr(e),r=D(t)?n:Hr(e,t);Sr(n,r)}Ar&&Ir(e,1,null==t?void 0:t.tagName,null==t?void 0:t.idx)}let _r=!1,Rr=null;function jr(){return Rr}function Br(e){Rr=e}function Wr(e,t){r.isTrue(R(t),`evaluateTemplate() second argument must be an imported template instead of ${G(t)}`),t=function(e){if(oe.ENABLE_HMR){const t=new Set;for(;Nn.has(e)&&!t.has(e);)t.add(e),e=Nn.get(e)}return e}(t);const n=_r,o=Rr;let a=[];return xo(e,e.owner,(()=>{Rr=e,Nr(1,e)}),(()=>{const{component:n,context:o,cmpSlots:s,cmpTemplate:l,tro:c}=e;c.observe((()=>{if(t!==l){if(function(e,t){e!==Mn&&(0===t.renderMode?r.isTrue("light"===e.renderMode,`Light DOM components can't render shadow DOM templates. Add an 'lwc:render-mode="light"' directive to the root template tag of ${we(t)}.`):r.isTrue(D(e.renderMode),`Shadow DOM components template can't render light DOM templates. Either remove the 'lwc:render-mode' directive from ${we(t)} or set it to 'lwc:render-mode="shadow"`))}(t,e),P(l)||To(e),c=t,!$n.has(c))throw new TypeError(`Invalid template returned by the render() method on ${e}. It must return an imported template (e.g.: \`import html from "./${e.def.name}.html"\`), instead, it has returned: ${G(t)}.`);e.cmpTemplate=t,o.tplCache=i(null),o.hasScopedStyles=function(e){const{stylesheets:t}=e;if(!D(t))for(let e=0;e<t.length;e++)if(F(t[e].$scoped$))return!0;return!1}(t),function(e,t){const{elm:n,context:r,renderer:o,renderMode:i,shadowMode:a}=e,{stylesheets:s,stylesheetToken:l}=t,c=1===i&&1===a,{hasScopedStyles:d}=r;let u,h,f;const{stylesheetToken:p,hasTokenInClass:m,hasTokenInAttribute:g}=r;m&&o.getClassList(n).remove($r(p)),g&&o.removeAttribute(n,$r(p)),D(s)||0===s.length||(u=l),D(u)||(d&&(o.getClassList(n).add($r(u)),h=!0),c&&(o.setAttribute(n,$r(u),""),f=!0)),r.stylesheetToken=u,r.hasTokenInClass=h,r.hasTokenInAttribute=f}(e,t);const n=Cr(e,t);o.styleVNode=0===n.length?null:function(e,t){const{renderer:n,renderMode:r,shadowMode:o}=e;if(1===r&&1===o)for(let e=0;e<t.length;e++)n.insertGlobalStylesheet(t[e]);else{if(n.ssr||n.isHydrating())return i=k.call(t,"\n"),kr.h("style",{key:"style",attrs:{type:"text/css"}},[kr.t(i)]);{const r=function(e){let t=e;for(;!P(t);){if(1===t.renderMode&&0===t.shadowMode)return t;t=t.owner}return t}(e),o=P(r);for(let e=0;e<t.length;e++)o?n.insertGlobalStylesheet(t[e]):n.insertStylesheet(t[e],r.cmpRoot)}}var i;return null}(e,n)}var c;!function(e,t){const{cmpSlots:n}=e,{slots:o=se}=t;for(const t in n)r.isTrue(y(n[t]),`Slots can only be set to an array, instead received ${G(n[t])} for slot "${t}" in ${e}.`),""!==t&&-1===b.call(o,t)&&ke(`Ignoring unknown provided slot name "${t}" in ${e}. Check for a typo on the slot attribute.`,e)}(e,t),function(e){if(oe.ENABLE_HMR){const t=e.def.ctor;let n=_n.get(t);D(n)&&(n=new Set,_n.set(t,n)),n.add(e);const r=e.cmpTemplate;if(r){let t=Fn.get(r);D(t)&&(t=new Set,Fn.set(r,t)),t.add(e);const n=r.stylesheets;D(n)||jn(n).forEach((t=>{t=Bn(t);let n=Rn.get(t);D(n)&&(n=new Set,Rn.set(t,n)),n.add(e)}))}}}(e),e.velements=[],_r=!0,a=t.call(void 0,kr,n,s,o.tplCache);const{styleVNode:d}=o;P(d)||S.call(a,d)}))}),(()=>{_r=n,Rr=o,Dr(1,e)})),r.invariant(y(a),"Compiler should produce html functions that always return an array."),a}function Vr(e,t){if(!f(t)&&D(t.wcStack)){const n=function(e){const t=[];let n=e;for(;!P(n);)M.call(t,we(n)),n=n.owner;return t.reverse().join("\n\t")}(e);s(t,"wcStack",{get:()=>n})}}let Gr=!1,Ur=null;function Kr(e){return Ur===e}function zr(e,t,n){const{component:r,callHook:o,owner:i}=e;xo(e,i,W,(()=>{o(r,t,n)}),W)}function qr(e,t,n,o){const{callHook:i,owner:a}=e;xo(e,a,W,(()=>{r.isTrue(R(t),`Invalid event handler for event '${o.type}' on ${e}.`),i(n,t,[o])}),W)}const Zr=new Map;function Xr(e){r.invariant(e.isDirty,`${e} is not dirty.`),e.tro.reset();const t=function(e){const{def:{render:t},callHook:n,component:r,owner:o}=e,i=Gr,a=jr();let s,l=!1;return xo(e,o,(()=>{Gr=!0,Br(e)}),(()=>{e.tro.observe((()=>{s=n(r,t),l=!0}))}),(()=>{Gr=i,Br(a)})),l?Wr(e,s):[]}(e);return e.isDirty=!1,e.isScheduled=!1,t}function Yr(e){{const t=jr();r.isFalse(e.isDirty,`markComponentAsDirty() for ${e} should not be called when the component is already dirty.`),r.isFalse(Gr,`markComponentAsDirty() for ${e} cannot be called during rendering of ${t}.`),r.isFalse(_r,`markComponentAsDirty() for ${e} cannot be called while updating template of ${t}.`)}e.isDirty=!0}const Qr=new WeakMap;function Jr(e,t){if(!R(t))throw new TypeError;let n=Qr.get(t);return D(n)&&(n=function(n){qr(e,t,void 0,n)},Qr.set(t,n)),n}const eo=i(null);function to(e,t){r.isTrue(y(t)&&t.length>0,"Optimize invokeServiceHook() to be invoked only when needed");const{component:n,def:o,context:i}=e;for(let e=0,r=t.length;e<r;++e)t[e].call(void 0,n,{},o,i)}let no=0;const ro=new WeakMap;function oo(e,t,n=[]){return t.apply(e,n)}function io(e,t,n){e[t]=n}function ao(e,t){return e[t]}function so(e){yo(e)}function lo(e){const t=mo(e);Pr(7,t),1===t.state&&co(e),ko(t),yo(t),Fr(7,t)}function co(e){uo(mo(e))}function uo(e){const{state:t}=e;if(2!==t){const{oar:t,tro:n}=e;n.reset();for(const e in t)t[e].reset();!function(e){r.isTrue(2!==e.state,`${e} must be inserted.`),_(e.isDirty)&&(e.isDirty=!0),e.state=2;const{disconnected:t}=eo;t&&to(e,t),$o(e)&&function(e){const{wiredDisconnecting:t}=e.context;xo(e,e,W,(()=>{for(let e=0,n=t.length;e<n;e+=1)t[e]()}),W)}(e);const{disconnectedCallback:n}=e.def;D(n)||(Nr(5,e),zr(e,n),Dr(5,e))}(e),Mo(e),function(e){const{aChildren:t}=e;Co(t)}(e)}!function(e){if(oe.ENABLE_HMR){const t=e.def.ctor;let n=_n.get(t);D(n)||n.delete(e);const r=e.cmpTemplate;if(r){n=Fn.get(r),D(n)||n.delete(e);const t=r.stylesheets;D(t)||jn(t).forEach((t=>{n=Rn.get(t),D(n)||n.delete(e)}))}}}(e)}function ho(e,t,n){const{mode:o,owner:a,renderer:s,tagName:l}=n,c={elm:e,def:t,idx:no++,state:0,isScheduled:!1,isDirty:!0,tagName:l,mode:o,owner:a,renderer:s,children:se,aChildren:se,velements:se,cmpProps:i(null),cmpFields:i(null),cmpSlots:i(null),oar:i(null),cmpTemplate:null,renderMode:t.renderMode,shadowMode:null,context:{stylesheetToken:void 0,hasTokenInClass:void 0,hasTokenInAttribute:void 0,hasScopedStyles:void 0,styleVNode:null,tplCache:ae,wiredConnecting:se,wiredDisconnecting:se},tro:null,component:null,cmpRoot:null,callHook:oo,setHook:io,getHook:ao};return c.shadowMode=function(e){const{def:t,renderer:n}=e,{isNativeShadowDefined:r,isSyntheticShadowDefined:o}=n;let i;if(o)if(0===t.renderMode)i=0;else if(r)if("any"===t.shadowSupportMode)i=0;else{const t=function(e){let t=e.owner;for(;!P(t)&&0===t.renderMode;)t=t.owner;return t}(e);i=P(t)||0!==t.shadowMode?1:0}else i=1;else i=0;return i}(c),c.tro=function(e){return new ge((()=>{const{isDirty:t}=e;_(t)&&(Yr(e),Eo(e))}))}(c),c.toString=()=>`[object:vm ${t.name} (${c.idx})]`,oe.ENABLE_FORCE_NATIVE_SHADOW_MODE_FOR_TEST&&(c.shadowMode=0),function(e,t){const n=Ur;let r;Nr(0,e),Ur=e;try{const o=new t;if(Ur.component!==o)throw new TypeError("Invalid component constructor, the class should extend LightningElement.")}catch(e){r=Object(e)}finally{if(Dr(0,e),Ur=n,!D(r))throw Vr(e,r),r}}(c,t.ctor),$o(c)&&function(e){const{context:t,def:{wire:n}}=e,o=t.wiredConnecting=[],i=t.wiredDisconnecting=[];for(const t in n){const a=n[t],s=Lo.get(a);if(r.invariant(s,"Internal Error: invalid wire definition found."),!D(s)){const{connector:n,computeConfigAndUpdate:r,resetConfigWatcher:a}=Ho(e,t,s),l=s.dynamic.length>0;M.call(o,(()=>{n.connect(),oe.ENABLE_WIRE_SYNC_EMIT||!l?r():Promise.resolve().then(r)})),M.call(i,(()=>{n.disconnect(),a()}))}}}(c),c}function fo(e){if(P(e)||!j(e)||!("cmpRoot"in e))throw new TypeError(`${e} is not a VM.`)}function po(e,t){ro.set(e,t)}function mo(e){const t=ro.get(e);return fo(t),t}function go(e){const t=ro.get(e);return D(t)||fo(t),t}function yo(e){F(e.isDirty)&&function(e,t){const{children:n}=e;if(e.children=t,(t.length>0||n.length>0)&&n!==t){const r=sr(t)?et:tt;xo(e,e,(()=>{Nr(2,e)}),(()=>{const o=So(e);r(o,n,t)}),(()=>{Dr(2,e)}))}1===e.state&&vo(e)}(e,Xr(e))}function vo(e){const{renderer:t,def:{renderedCallback:n}}=e;if(F(t.ssr))return;const{rendered:r}=eo;r&&to(e,r),D(n)||(Nr(4,e),zr(e,n),Dr(4,e))}let wo=[];function bo(){Pr(8),r.invariant(wo.length,`If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of ${wo}.`);const e=wo.sort(((e,t)=>e.idx-t.idx));wo=[];for(let t=0,n=e.length;t<n;t+=1){const r=e[t];try{yo(r)}catch(r){throw t+1<n&&(0===wo.length&&ce(bo),S.apply(wo,E.call(e,t+1))),Fr(8),r}}Fr(8)}function ko(e){const{state:t}=e;if(1===t)return;e.state=1;const{connected:n}=eo;n&&to(e,n),$o(e)&&function(e){const{wiredConnecting:t}=e.context;for(let e=0,n=t.length;e<n;e+=1)t[e]()}(e);const{connectedCallback:r}=e.def;D(r)||(Nr(3,e),zr(e,r),Dr(3,e))}function $o(e){return d(e.def.wire).length>0}function Mo(e){const{velements:t}=e;for(let e=t.length-1;e>=0;e-=1){const{elm:n}=t[e];if(!D(n)){const e=go(n);D(e)||uo(e)}}}function Co(e){for(let t=0,n=e.length;t<n;t+=1){const n=e[t];P(n)||!y(n.children)||D(n.elm)||(D(n.ctor)?Co(n.children):uo(mo(n.elm)))}}function To(e){const{children:t,renderer:n}=e,r=So(e);for(let e=0,o=t.length;e<o;e++){const o=t[e];P(o)||D(o.elm)||n.remove(o.elm,r)}e.children=se,Mo(e),e.velements=se}function Eo(e){F(e.renderer.ssr)||F(e.isScheduled)||(e.isScheduled=!0,0===wo.length&&ce(bo),M.call(wo,e))}function xo(e,t,n,r,o){let i;n();try{r()}catch(e){i=Object(e)}finally{if(o(),!D(i)){Vr(e,i);const n=P(t)?void 0:function(e){let t=e;for(;!P(t);){if(!D(t.def.errorCallback))return t;t=t.owner}}(t);if(D(n))throw i;To(e),Nr(6,e),zr(n,n.def.errorCallback,[i,i.wcStack]),Dr(6,e)}}}function So(e){return 1===e.renderMode?e.cmpRoot:e.elm}const Lo=new Map;class Oo extends CustomEvent{constructor(e,{setNewContext:t,setDisconnectedCallback:n}){super(e,{bubbles:!0,composed:!0}),a(this,{setNewContext:{value:t},setDisconnectedCallback:{value:n}})}}function Ho(e,t,n){const{method:r,adapter:o,configCallback:i,dynamic:a}=n,l=D(r)?function(e,t){const{cmpFields:n}=e;return r=>{r!==e.cmpFields[t]&&(n[t]=r,ye(e,t))}}(e,t):function(e,t){return n=>{xo(e,e.owner,W,(()=>{t.call(e.component,n)}),W)}}(e,r);let c,d;s(l,"$$DeprecatedWiredElementHostKey$$",{value:e.elm}),s(l,"$$DeprecatedWiredParamsMetaKey$$",{value:a}),xo(e,e,W,(()=>{d=new o(l)}),W);const{computeConfigAndUpdate:u,ro:h}=function(t,n,r){let o=!1;const i=new ge((()=>{!1===o&&(o=!0,Promise.resolve().then((()=>{o=!1,i.reset(),a()})))})),a=()=>{let r;i.observe((()=>r=n(t))),(t=>{xo(e,e,W,(()=>{d.update(t,c)}),W)})(r)};return{computeConfigAndUpdate:a,ro:i}}(e.component,i);return D(o.contextSchema)||function(e,t,n){const{adapter:r}=t,o=function(e){return Ao.get(e)}(r);if(D(o))return;const{elm:i,renderer:a,context:{wiredConnecting:s,wiredDisconnecting:l}}=e;M.call(s,(()=>{const e=new Oo(o,{setNewContext(e){n(e)},setDisconnectedCallback(e){M.call(l,e)}});a.dispatchEvent(i,e)}))}(e,n,(t=>{c!==t&&(c=t,1===e.state&&u())})),{connector:d,computeConfigAndUpdate:u,resetConfigWatcher:()=>h.reset()}}const Ao=new Map;function Io(e,t,n,r){t.adapter&&(t=t.adapter);const o={adapter:t,method:e.value,configCallback:n,dynamic:r};Lo.set(e,o)}function No(e,t,n,r){t.adapter&&(t=t.adapter);const o={adapter:t,configCallback:n,dynamic:r};Lo.set(e,o)}const Do=i(null),Po=document.head||document.body||document,Fo=R(CSSStyleSheet.prototype.replaceSync)&&y(document.adoptedStyleSheets),_o=i(null),Ro=i(null),jo=new WeakMap;let Bo,Wo,Vo;if(function(){if("undefined"==typeof customElements)return!1;try{const e=HTMLElement;class t extends e{}return customElements.define("lwc-test-"+Math.floor(1e6*Math.random()),t),new t,!0}catch(e){return!1}}())Bo=customElements.get.bind(customElements),Wo=customElements.define.bind(customElements),Vo=HTMLElement;else{const e=i(null),t=new WeakMap;Wo=function(n,r){if(n!==N.call(n)||e[n])throw new TypeError("Invalid Registration");e[n]=r,t.set(r,n)},Bo=function(t){return e[t]},Vo=function e(){if(!(this instanceof e))throw new TypeError("Invalid Invocation");const{constructor:n}=this,r=t.get(n);if(!r)throw new TypeError("Invalid Construction");const o=document.createElement(r);return g(o,n.prototype),o},Vo.prototype=HTMLElement.prototype}let Go=!1;const Uo={ssr:!1,isHydrating:()=>Go,isNativeShadowDefined:Z.$isNativeShadowRootDefined$,isSyntheticShadowDefined:h.call(Element.prototype,"$shadowToken$"),createElement:(e,t)=>D(t)?document.createElement(e):document.createElementNS(t,e),createText:e=>document.createTextNode(e),createComment:e=>document.createComment(e),insert(e,t,n){t.insertBefore(e,n)},remove(e,t){t.removeChild(e)},nextSibling:e=>e.nextSibling,attachShadow:(e,t)=>Go?e.shadowRoot:e.attachShadow(t),setText(e,t){e.nodeValue=t},getProperty:(e,t)=>e[t],setProperty(e,t,n){e instanceof Element&&!(t in e)&&r.fail(`Unknown public property "${t}" of element <${e.tagName}>. This is likely a typo on the corresponding attribute "${Q(t)}".`),e[t]=n},getAttribute:(e,t,n)=>D(n)?e.getAttribute(t):e.getAttributeNS(n,t),setAttribute:(e,t,n,r)=>D(r)?e.setAttribute(t,n):e.setAttributeNS(r,t,n),removeAttribute(e,t,n){D(n)?e.removeAttribute(t):e.removeAttributeNS(n,t)},addEventListener(e,t,n,r){e.addEventListener(t,n,r)},removeEventListener(e,t,n,r){e.removeEventListener(t,n,r)},dispatchEvent:(e,t)=>e.dispatchEvent(t),getClassList:e=>e.classList,setCSSStyleProperty(e,t,n,r){e.style.setProperty(t,n,r?"important":"")},getBoundingClientRect:e=>e.getBoundingClientRect(),querySelector:(e,t)=>e.querySelector(t),querySelectorAll:(e,t)=>e.querySelectorAll(t),getElementsByTagName:(e,t)=>e.getElementsByTagName(t),getElementsByClassName:(e,t)=>e.getElementsByClassName(t),getChildren:e=>e.children,getChildNodes:e=>e.childNodes,getFirstChild:e=>e.firstChild,getFirstElementChild:e=>e.firstElementChild,getLastChild:e=>e.lastChild,getLastElementChild:e=>e.lastElementChild,isConnected:e=>e.isConnected,insertGlobalStylesheet(e){if(!D(Do[e]))return;Do[e]=!0;const t=document.createElement("style");t.type="text/css",t.textContent=e,Po.appendChild(t)},insertStylesheet(e,t){Fo?function(e,t){let n=Ro[e];D(n)&&(n=new CSSStyleSheet,n.replaceSync(e),Ro[e]=n),t.adoptedStyleSheets.includes(n)||(t.adoptedStyleSheets=[...t.adoptedStyleSheets,n])}(e,t):function(e,t){let n=jo.get(t);if(D(n)&&(n=i(null),jo.set(t,n)),n[e])return;n[e]=!0;let r=_o[e];D(r)?(r=document.createElement("style"),r.type="text/css",r.textContent=e,_o[e]=r):r=r.cloneNode(!0),t.appendChild(r)}(e,t)},assertInstanceOfHTMLElement(e,t){r.invariant(e instanceof HTMLElement,t)},defineCustomElement:Wo,getCustomElement:Bo,HTMLElement:Vo},Ko=Node,zo=new WeakMap,qo=new WeakMap;function Zo(e,t){r.isTrue(e,"callNodeSlot() should not be called for a non-object");const n=t.get(e);return D(n)||n(e),e}const{appendChild:Xo,insertBefore:Yo,removeChild:Qo,replaceChild:Jo}=Ko.prototype;o(Ko.prototype,{appendChild(e){return Zo(Xo.call(this,e),zo)},insertBefore(e,t){return Zo(Yo.call(this,e,t),zo)},removeChild(e){return Zo(Qo.call(this,e),qo)},replaceChild(e,t){const n=Jo.call(this,e,t);return Zo(n,qo),Zo(e,zo),n}});Node;const ei=new Map;s(Qt,"CustomElementConstructor",{get(){return function(e){if(e===Qt)throw new TypeError("Invalid Constructor. LightningElement base class can't be claimed as a custom element.");let t=ei.get(e);return D(t)&&(t=function(e){const t=Gn(e);return class extends t.bridge{constructor(){super(),ho(this,t,{mode:"open",owner:null,tagName:this.tagName,renderer:Uo})}connectedCallback(){lo(this)}disconnectedCallback(){co(this)}}}(e),ei.set(e,t)),t}(this)}}),l(Qt),m(Qt.prototype),t.mL=Qt,t.az=function(e,t){if(!j(t)||P(t))throw new TypeError(`"createElement" function expects an object as second parameter but received "${G(t)}".`);const n=t.is;if(!R(n))throw new TypeError('"createElement" function expects an "is" option with a valid component constructor.');const r=lr(e,Uo);let o=!1;const i=new r((r=>{ho(r,Gn(n),{tagName:e,mode:"closed"!==t.mode?"open":"closed",owner:null,renderer:Uo}),zo.set(r,lo),qo.set(r,co),o=!0}));return o||console.error(`Unexpected tag name "${e}". This name is a registered custom element, preventing LWC to upgrade the element.`),i},t.RM=function(e,{tmpl:t}){return Zr.set(e,t),e},t.ij=function(e,t){const n=e.prototype,{publicProps:o,publicMethods:a,wire:l,track:d,fields:u}=t,h=i(null),f=i(null),p=i(null),m=i(null),g=i(null),y=i(null);let v;if(!D(o))for(const t in o){const r=o[t];if(y[t]=r.config,v=c(n,t),r.config>0){if(wn(e,t,v),D(v))throw new Error;v=un(t,v)}else vn(0,t,v),v=D(v)||D(v.get)?cn(t):un(t,v);f[t]=v,s(n,t,v)}if(D(a)||L.call(a,(e=>{if(v=c(n,e),function(e,t,n){(D(n)||!R(n.value)||_(n.writable))&&r.fail(`Invalid @api ${t} method.`)}(0,e,v),D(v))throw new Error;h[e]=v})),!D(l))for(const e in l){const{adapter:t,method:o,config:i,dynamic:a=[]}=l[e];if(v=c(n,e),1===o){if(r.isTrue(t,`@wire on method "${e}": adapter id must be truthy.`),yn(0,e,v),D(v))throw new Error;p[e]=v,Io(v,t,i,a)}else r.isTrue(t,`@wire on field "${e}": adapter id must be truthy.`),gn(0,e,v),v=sn(e),m[e]=v,No(v,t,i,a),s(n,e,v)}if(!D(d))for(const e in d)v=c(n,e),mn(0,e,v),v=ln(e),s(n,e,v);if(!D(u))for(let e=0,t=u.length;e<t;e++){const t=u[e];v=c(n,t),pn(0,t,v);const r=!D(o)&&t in o,i=!D(d)&&t in d;r||i||(g[t]=hn(t))}return function(e,t){bn.set(e,t)}(e,{apiMethods:h,apiFields:f,apiFieldsConfig:y,wiredMethods:p,wiredFields:m,observedFields:g}),e},t.Pv=function(e){return $n.add(e),e}},238:(e,t)=>{t.Z=void 0}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var i=t[r]={exports:{}};return e[r](i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),(()=>{var e=n(709);const t=[function(e,t){return[".container",t?"["+t+"]":""," {width: 70vw;margin: 0 auto;}"].join("")}];var r=n(238);const o=[function(e,t){var n=t?"["+t+"]":"";return[".header",n," {background: rgb(170, 0, 255);color: aliceblue;}.game-container",n," {width: 100%;height: 60vh;background: #d3e3eb;}.game-play",n," div",n," {width: 20px;height: 20px;display: inline-block;}.snake",n," {background: green !important;border-radius: 50%;}.food",n," {background: #ff7b00 !important;border-radius: 100%;}.overlay",n," {position: relative;width: 100%;margin-top: -30vh;left: 0;bottom: 0;z-index: 9;}.overlay-content",n," {position: relative;top: 50%;text-align: center;}.game-controls",n," {visibility: hidden;width: 100%;text-align: center;margin-top: 15%;}@media screen and (max-width: 906px) {.game-controls",n," {visibility: visible;}}"].join("")}];function i(e,t,n,r){const{d:o,t:i,h:a,k:s,i:l,b:c}=e,{_m0:d,_m1:u,_m2:h,_m3:f,_m4:p,_m5:m}=r;return[a("div",{classMap:{header:!0,"slds-var-p-around_medium":!0,"slds-text-align_center":!0,"slds-text-title_caps":!0},key:0},[i("Score : "+o(t.score))]),a("div",{classMap:{"game-container":!0},key:1},[a("div",{classMap:{"game-play":!0},key:2},l(t.gameBlocks,(function(e){return a("div",{className:e.class,attrs:{"data-reference":e.id},key:s(3,e.id)},[i(" ")])}))),a("div",{classMap:{"slds-hide_small":!0,"game-controls":!0},key:4},[a("button",{key:5,on:{click:d||(r._m0=c(t.moveUp))}},[i("UP")]),a("br",{key:6},[]),a("br",{key:7},[]),a("button",{key:8,on:{click:u||(r._m1=c(t.moveLeft))}},[i("LEFT")]),a("button",{key:9,on:{click:h||(r._m2=c(t.moveRight))}},[i("RIGHT")]),a("br",{key:10},[]),a("br",{key:11},[]),a("button",{key:12,on:{click:f||(r._m3=c(t.moveDown))}},[i("DOWN")])]),t.showOverlay?a("div",{classMap:{overlay:!0},key:13},[a("div",{classMap:{"overlay-content":!0},key:14},[t.gameOver?a("div",{classMap:{"slds-text-heading_large":!0},key:15},[i("Game Over!")]):null,t.gameOver?a("br",{key:16},[]):null,t.gameOver?a("button",{classMap:{"slds-button":!0,"slds-button_brand":!0},key:17,on:{click:p||(r._m4=c(t.resetGame))}},[i("Play Again")]):null,t.gameOver?null:a("div",{classMap:{"slds-text-heading_medium":!0},key:18},[i("Use Arrow Keys to move the snake")]),t.gameOver?null:a("br",{key:19},[]),t.gameOver?null:a("button",{classMap:{"slds-button":!0,"slds-button_brand":!0},key:20,on:{click:m||(r._m5=c(t.startGame))}},[i("Start Game")])])]):null])]}const a=(0,e.Pv)(i);i.stylesheets=[],o&&i.stylesheets.push.apply(i.stylesheets,o),r.Z&&i.stylesheets.push.apply(i.stylesheets,r.Z),i.stylesheetToken="my-game_game";class s extends e.mL{constructor(...e){super(...e),this.score=0,this.blockSize=20,this.gameBlocks=[],this.renderedComplete=!1,this.xSpeed=1,this.ySpeed=0,this.xHead=0,this.yHead=0,this.xMax=void 0,this.yMax=void 0,this.showOverlay=!1,this.gameOver=!1,this.intervalObjt=void 0,this.tail=[]}startGame(){this.showOverlay=!1,this.intervalObjt=setInterval((()=>{this.move()}),200)}move(){if(this.tail[this.tail.length-1]!==`${this.xHead}:${this.yHead}`){this.tail.push(`${this.xHead}:${this.yHead}`);let e=this.tail.shift(),t=this.gameBlocks.findIndex((t=>t.id===e));this.gameBlocks[t].snake=!1,this.gameBlocks[t].class=""}if(this.xHead+=this.xSpeed,this.yHead+=this.ySpeed,this.xHead>=this.xMax&&(this.xHead=0),this.xHead<0&&(this.xHead=this.xMax-1),this.yHead>=this.yMax&&(this.yHead=0),this.yHead<0&&(this.yHead=this.yMax-1),this.tail.includes(`${this.xHead}:${this.yHead}`))this.exitGame();else{let e=this.gameBlocks.findIndex((e=>e.id===`${this.xHead}:${this.yHead}`));this.gameBlocks[e].snake=!0,this.gameBlocks[e].class="snake",this.gameBlocks[e].food&&(this.score++,this.tail.push(`${this.xHead}:${this.yHead}`),this.gameBlocks[e].food=!1,this.generateFood())}}addKeyBoardControls(){window.addEventListener("keydown",(e=>{switch(e.preventDefault(),e.key){case"ArrowUp":this.moveUp();break;case"ArrowDown":this.moveDown();break;case"ArrowLeft":this.moveLeft();break;case"ArrowRight":this.moveRight()}}))}moveLeft(){this.xSpeed=-1,this.ySpeed=0}moveRight(){this.xSpeed=1,this.ySpeed=0}moveUp(){this.xSpeed=0,this.ySpeed=-1}moveDown(){this.xSpeed=0,this.ySpeed=1}generateFood(){let e=Math.floor(Math.random()*this.xMax),t=Math.floor(Math.random()*this.yMax),n=this.gameBlocks.findIndex((n=>n.id===`${e}:${t}`));this.gameBlocks[n].class="food",this.gameBlocks[n].food=!0}renderGameBlocks(){const e=this.template.querySelector(".game-container");let t=e.clientWidth,n=e.clientHeight;this.xMax=Math.floor(t/this.blockSize),this.yMax=Math.floor(n/this.blockSize);let r=[];for(let e=0;e<this.yMax;e++)for(let t=0;t<this.xMax;t++){let n;n=0===t&&0===e?{id:`${t}:${e}`,snake:!0,food:!1,class:"snake"}:{id:`${t}:${e}`,snake:!1,food:!1,class:""},r.push(n)}this.gameBlocks=r}resetGameMetrics(){this.xSpeed=1,this.ySpeed=0,this.xHead=0,this.yHead=0,this.tail=[],this.score=0,this.renderGameBlocks(),this.generateFood(),clearInterval(this.intervalObj)}resetGame(){this.resetGameMetrics(),this.startGame()}exitGame(){this.showOverlay=!0,this.gameOver=!0,clearInterval(this.intervalObjt)}renderedCallback(){this.renderedComplete||(this.renderedComplete=!0,this.renderGameBlocks(),this.addKeyBoardControls(),this.generateFood(),this.startGame())}}(0,e.ij)(s,{track:{gameBlocks:1},fields:["score","blockSize","renderedComplete","xSpeed","ySpeed","xHead","yHead","xMax","yMax","showOverlay","gameOver","intervalObjt","tail"]});const l=(0,e.RM)(s,{tmpl:a});function c(e,t,n,r){const{c:o,h:i}=e;return[i("div",{classMap:{container:!0},key:0},[o("my-game",l,{key:1},[])])]}const d=(0,e.Pv)(c);c.stylesheets=[],t&&c.stylesheets.push.apply(c.stylesheets,t),r.Z&&c.stylesheets.push.apply(c.stylesheets,r.Z),c.stylesheetToken="my-app_app";class u extends e.mL{}const h=(0,e.RM)(u,{tmpl:d}),f=(0,e.az)("my-app",{is:h});document.querySelector("#main").appendChild(f)})()})();